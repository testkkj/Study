전자정부프레임워크
  2. 개발환경 구성하기
    - 지원 범위 : 개발, 테스트, 빌드, 형상관리를 포함한 전체 개발 주기
    2.1. 개발환경 구성
      - 구현도구, 테스트도구, 형상/변경관리 도구, 배포도구

        개발흐름
        개발자 개발환경에서 소스코드작성, 컴파일, 테스트 후 실행 가능한 형태로 빌드
        개인별 소스코드는 형상관리 시스템에 통합 저장
        형상관리 시스템에 자신의 소스코드를 반영 혹은 타인의 소스코드를 통합하는 공동작업 형태로 개발을 진행
        배포도구는 형상관리 시스템에서 소스코드를 불러와 통합 빌드
        서버에서 실행 가능한 형태로 구조화하여 배포

        개발환경 주요 오픈소스
        ==========================================================
        |        구분         |               설명               |
        | 구현도구            | Eclipse, PMD, Maven(빌드)        |
        | 테스트도구          | JUnit, EasyMock, DbUnit, EclEmma |
        | 형상/변경관리  도구 | Subversion, jTrac                |
        | 배포도구            | Hudson, Nexus, Maven             |
        ==========================================================
        Eclipse    : 자바소스코드 편집, 컴파일, 테스트, 실행을 지원하는 개발도구
        PMD        : Eclipse의 플러그인 룰셋 기반으로 소스코드 오류 검사
        Maven      : 소스코드 컴파일에 필요한 라이브러리 관리와 컴파일, 테스트, 빌드 작업 지원
        Junit      : 단위테스트 코드 작성지원
        EasyMock   : 웹 어플리케이션 없이 테스트 할수 있도록 테스트 환경 지원
        DBunit     : DB에 테스트 데이터 생성 및 검증값과 같은지 비교하는 환경 지원
        EclEmma    : 단위테스트가 수행된 부분을 퍼센트 형태로 알려주는 커버리지 테스트 지원
        SubVersion : 형상관리도구 소스코드통합, 버전관리 지원
        jTrac      : 변경관리 이력 추적
        Hudson     : 테스트와 통합을 지원하는 CI(Continuous Intergration) 도구
          * CI : 지속적인 통합 / 초기의 코드와 작성중 변경된 코드를 통합할때 시간간격이 벌어질수록 통합이 어려워져서 처음부터 작성하게 될수도 있는 상황을 방지하기 위해 "초기부터 자주" 통합하는 것
        Nexus : Maven 라이브러리를 3rd 파티로 제공할 때 활용

    2.2. 개발환경 설치 및 구성
      3가지 방법
      1. 표준프레임워크 홈페이지 -> 교육교재 활용
         모든 구성이 완료된 상태
         링크 : https://www.egovframe.go.kr/cop/bbs/selectBoardArticle.do?nttId=1321&bbsId=BBSMSTR_000000000004&menu=4
      2. 표준프레임워크 개발환경 다운로드 후 JDK, TOMCAT 설치
          eclipse 디렉터리안에 eclipse.ini에 설치된 JDK 정보(-vm JDK설치경로\bin\javaw.exe)를 다음과 같이 추가한다.
         링크 :https://www.egovframe.go.kr/EgovDevEnvRelease_300.jsp?menu=3&submenu=2&leftsub=2#
      3. 기존의 Eclipse에 표준프레임워크 플러그인 추가

  3. 개발자 개발환경 활용
    - 표준프레임워크 개발자 개발도구는 구현 도구인 Eclipse를 활용하여 개발 Maven을 활용하여 라이브러리 관리 및 빌드를 수행한다.

    3.1. 구현도구 활용
      메뉴바의 메뉴중 eGovFrame에서 프로젝트 생성 및 관련 파일과 기능을 사용할수있다.
      예제 프로젝트 생성
      메뉴바의 egovFrame 버튼 클릭 -> Start -> new web project를 클릭한후 프로젝트명, 그룹아이디를 입력 후 Next 버튼을 클릭하고 Generate Example을 체크해야 샘플 프로젝트가 생성된다. 프로젝트가 생성되면 Run As -> Maven install을 선택해 프로젝트를 빌드한다.
      * jdk가 1.7이 아니면 오류가 발생하는데 샘플이 1.7에 맞춰져 있으므로 프로젝트를 오른쪽 클릭 후 Properties를 선택하고 Java Compiler를 사용중인 JDK로 맞춰주면 오류 해결
      Run As -> Run on server를 선택하면 정상 실행된다.

      라이브러리 관리
        - Build Path -> Configure Build Path 안의 Libraries탭에서 라이브러리 추가 수정 삭제가 가능하다.
        - 프로젝트의 모든 라이브러리를 build path에 개별등록을 하게 되면 불편하기 때문에 Maven은 의존성 설정을 활용하여 관리하는 방법을 제공한다.
          firstexample 프로젝트의 라이브러리는 43개이고 pom.xml에 설정된 dependency는 9개 이다.
          나머지 라이브러리는 egovframework.rte.ptl.mvc에서 참조하는 라이브러리를 함께 이용한다.
          egovframework.rte.ptl.mvc와 egovframework.rte.psl.dataacess가 최상위로 이 둘에게 종속성을 가진 하위 라이브러리들이 모두 추가되는 형식으로 추정된다.

          라이브러리 설정 방법
          <dependency>
            <groupId>egovframework.rte</groupId>  라이브러리 식별 namespace
            <artifactId>egovframework.rte.ptl.mvc</artifactId>  라이브러리 명
            <version>${egovframework.rte.version}</version>  버전정보
            <exclusions>  옵션이며, 충돌 등의 이유로 특정 라이브러리 의존성 제거
              <exclusion>
                <artifactId>commons-logging</artifactId>
                <groupId>commons-logging</groupId>
              </exclusion>
            </exclusions>
          </dependency>

          처음 Maven 실행시 local repository(사용자 디렉터리 밑에 .m2\repository)에 라이브러리가 없다면
          http://repo1.maven.org/maven2/ 와 http://www.egovframe.go.kr/maven/에서 라이브러리를
          다운(원격저장소)받으며 내부망의 경우는 추가로 세팅이 필요하다.
      3.2.2. 빌드 관리
        - Maven에서는 디렉토리 구조 정규화를 통해 컴파일과 패키징을 쉽게 수행 가능하다.
        디렉토리 구조
        firstExample
          >src/main/java  : 자바 소스파일
          >src/main/resource  : 배포할 리소스, sml, properties
          >src/main/java
          >src/main/resource
          >maven dependencies
          >jre system library
          >src
            >main
              >webapp  : 웹 어플리케이션 리소스(html, js 등)
            >test
          >target  : build된 output 위치
          pom.xml  :프로젝트 객체 모델, 빌드 의존성 등 정보를 가짐

          실제 소스와 테스트 소스로 나뉘며 resuource 디렉토리에는 jar/war로 패키징될때 함께 배포되어야할 설정파일등의 리소스가 있다.
          웹프로젝트의 경우 webapp 밑에 MVC 설정과 웹리소스(HTML, JS, 이미지등)이 있다.

          Maven 빌드 생명주기
          validate -> generate-sources -> compile -> test -> package -> install -> deploy
          현재설정과 pom.xml의 내용의 유효성 확인
          플러그인 소스코드 추가가 필요하면 실행
          소스코드 컴파일 컴파일된 클래스는 타겟디렉토리에 저장됨
          테스트케이스 실행
          바이너리 파일을 jar / war로 변환
          압축된 패키지를 로컬 메이븐 저장소에 추가
          압축파일을 원격 메이븐 저장소에 추가

          대체로 인스톨로 실행하고 생명주기 앞부분도 같이 실행됨
      3.2.3. Maven 설정
        - Maven 프로젝트는 빌드 되어 로컬 또는 원격 Repository 에 배포될 수 있기 때문에 자체적으로 Group Id, Artifact Id, 버전 정보와
          pom.xml에 프로젝트의 정보, 의존성, 빌드 세팅(플러그인) 정보를 포함하고 있다.
          pom.xml은 artifact / dependencies / plugins로 크게 구분됨

          Maven 은 빌드 작업시에 생명주기 단계별로 플러그인을 바인딩하여 작업을 처리함
          플러그인의 설정은 pom.xml 에서 pluginManagement 에 기술되고 주요 Maven 플러그인 정보는

          ==========================================================================
          |  단계  |        plugin         |                설명                   |
          ==========================================================================
          |compile | maven-compiler-plugin | 소스코드 컴파일                       |
          ==========================================================================
          |test    | maven-test-plugin     | 단위테스트 (Junit) 실행과 리포트 생성 |
          |        | maven-surefire-plugin |                                       |
          ==========================================================================
          |package | maven-jar-plugin      |                                       |
          |        | maven-war-plugin      | 압축파일 생성                         |
          ==========================================================================
          |emma    | maven-emma-plugin     | Code coverage report 생성             |
          ==========================================================================

          Maven install로 빌드를 수행하면 compile, test, package, install의 순서로 실행
          compile 에서 resources 플러그인이 실행되어 소스코드가 copy 되고 compiler 플러그인이 동작하여 컴파일.
          Test단계에서 test 플러그인이 실행되어 단위테스트를 수행하고, surefire 플러그인이 테스트결과 리포트를 생성.
          Package 단계에서 war 플러그인이 동작되어 war 배포파일이 생성.
          Install단계에서 로컬 Repository에 배포되게 된다.

  4. 서버 개발환경 활용
    Subversion과 Jenkins

    4.1. 형상관리 도구 활용
      4.1.1. Subversion 개요 및 설치
        visualsvn 설명 생략

      4.1.2. Revisions
        전체 리비전과 파일별 리비전으로 나눔

      4.1.3. Eclipse와 연동
        최초 커밋으로 SVN 연동 후 check out으로 저장소의 파일을 받아오고
        commit(엽로드)과 update(다운로드)로 버전을 관리해 나간다.

    4.2. 배포 도구 활용
      4.2.1. CI(Continuous Intergration) 개요 및 설치
        - 일반적인 프로젝트의 가장 큰 위험 요소는 에러, 미개발, 요구사항 미 충족등이 오픈직전에 발견되는것
          이러한 문제를 해결하려는 개념이 CI 상시적으로 통합과 테스트를 수행하는 개념
        - 형상관리 서버에서 통합된 소스코드를 CI에서 check out 하여 자동으로 테스트 빌드수행
        - Hubson과 Jenkins의 기능이 거의 일치하고 Hudson의 업데이트가 비정기적인 이유로 Jenkins로 설명 진행
          Jenkins 압축파일을 다운로드 받아서 tomcat등의 WAS의 webapp 밑에 압축을 풀면 설치 완료
          그후 톰캣을 실행하고 http://localhost:8080/jenkins에 접속하여 세팅을 해주면 된다.
        - 설정 완료후 화면에서 작업을 추가해주는데 이름을 입력하고 작업은 freestyle project로 선택 한후
          소스 코드 관리 탭에서 SUbvision 선택후 URL과 프로젝트이름 입력하고 인증을 해야 하는데
          credentials 의 add에 Subvision의 아이디와 패스워드 입력 한 후 선택하면 된다.
        - 주기적인 실행을 위하여 빌드 유발 탭에서 Build periodically를 선택하고 Schedule을 입력한다.
          * * * * * 다섯 자리에 minute(0~59) hour(0~23) dom(1~31) month(1~12) dow(0~7)를 입력하면 된다.
        - 빌드 설정은 build 탭에서 add build step의 목록 중 invoke top-level maven targerts를 선택하고
          고급 설정을 눌러서 goals는 package 또는 install을 선택하고 POM은 pom.xml을 입력하고 저장하면 설정이 완료된다.

  5. 실행환경 소개
    5.1. 실행환경 구성
      화면처리, 업무처리, 데이터처리, 연계, 공통기반, 배치처리 Layer로 구성된다.
      ===========================================================================
      |      구분      |                          설명                          |
      |화면처리 Layer  |사용자 인터페이스 및 화면 구현에 필요한 기능과 구조 제공|
      |업무처리 Layer  |예외처리 및 업무흐름처리 기능을 제공                    |
      |데이터처리 Layer|개발자가 작성한 소스코드를 통합하여 버전관리 수행       |
      |연계 Layer      |SOAP기반 웹 서비스 기능 제공                            |
      |공통기반 Layer  |재사용 컴포넌트, 로그 등 개발에 필수적인 기능 제공      |
      |배치처리 Layer  |일괄처리를 위한 설정 및 실행기능 제공                   |
      ===========================================================================
      Layer별 하위 서비스를 제공하는데 국제화, Ajax, DataSource, Data Access, ORM
      IoC, AOP, Logging등을 지원한다.

      위 기능을 제공하는 주요 오픈소스 목록
      ================================================================
      |      구분      |                     설명                    |
      |화면처리 Layer  |Spring Mvc, Apache commons validator, jQuuery|
      |업무처리 Layer  |Spring                                       |
      |데이터처리 Layer|DBCP, iBatis/MyBatis, Hibernate              |
      |연계 Layer      |Apache CXF                                   |
      |공통기반 Layer  |Spring, Log4j, Spring Security               |
      |배치처리 Layer  |Spring Batch                                 |
      ================================================================
      주요 패턴 및 기능은 Spring Framework 기반으로 한다.

      주요 기능에 대한 설명
      ========================================================================
      |구분|                               설명                              |
      |CORE|가장 기본적인 부분, IoC와 DI를 제공                              |
      |DAO |JDBC 추상화 계층을 제공, 프로그램적 트랜잭션/선언적 트랜잭션 제공|
      |ORM |JPA,FDO,Hibernate같은 객체 관계 맵핑을 위한 통합 계층 제공       |
      |AOP |Aspect 지향 프로그램 방식 지원                                   |
      |WEB |웹기반 통합기능 제공                                             |
      |JEE |Spring 환경에서 JavaEE 기술 사용을 지원                          |
      ========================================================================

  6. DI(Dependency Injection)
    소스코드 재사용시 소스코드의 종속성 부분은 재사용에 어려움을 주게됨.
    DI는 소스코드간의 직접적인 종속성을 배제하고 XML설정파일 혹은 Annotation을
    활용하게 해서 소스코드를 직접 수정하지 않고 참조할수 있게 해줌.

    6.1. 자바 인터페이스 활용
      자바 인터페이스는 구현할 동작을 지정하는 추상형으로 클래스 형식을 정의
      클래스에서 외부로 노출되어 활용될 변수와 메서드 정보를 제공하여 참조를
      용이하게 하면서 다른 클래스로 대체하기위해 필요한 정보를 제공
      인터페이스의 메소드만 구현되면 다른 클래스로 교체하여 사용 가능
      일반적인 컴포넌트 구성시 인터페이스와 클래스를 묶어서 구성함
      외부 클래스에서 활용 가능한 메소드는 인터페이스에 기술되어 있으므로 참조하여 작성
      인터페이스를 활용해서 추상화와 캡슐화가 가능하다.
      외부에 노출되어야할 메소드만 인터페이스에 작성하면 외부에서 해당 메소드만 참조가능

      자바 인터페이스 형식
      interface 인터페이스명 {
          public static final 타입 상수이름 = 값;
          public abstract 메서드이름 (매개변수목록);
      }

      nameservice 인터페이스 작성
      interface NameService {
          public String getName(String id);
      }

      nameserviceimpl 클래스 작성
      public class NameServiceImpl implements NameService {
          *반드시 구현해야 하는 클래스(interface에 정의된 클래스)
          public String getName(String id) {
              String name = id + "eGovFrame";
              return name;
          }

          * 내부에서 사용하는 클래스
          public String get Customer(String id) {
              return "Customer";
          }
      }

      다른 클래스에서 참조시 interface를 타입으로 인스턴스 생성시 인스턴스에 있는
      메소드만 호출가능하고 class타입으로 인스턴스 생성시 전체 호출이 가능
      컴포넌트를 만드는 가장 중요한 이유는 구현된 기능을 다른 기능으로 쉽게 교체하여
      활용하게 하는 것.

    6.2. DI개념
      interface를 활용하면 동일한 type을 유지할수 있어 컴포넌트 구현과 활용에 유리하다.
      DI는 클래스 인스턴스를 생성할 클래스를 소스코드에 지정하지 않고 인터페이스를 활용하여
      Type만 지정한다.

      XML설정 파일이나  annotation을 확용하여 실제 인스턴스를 생성할 클래스를 지정
      수정할 경우 XML 설정파일, annotation정보를 수정하여 적용 가능.

      Spring이 동작하면서 설정파일, Annoataion에 등록된 클래스 정보를 읽고 동작시점에 dependency를 생성
      DI를 활용해서 new 생성자와 같은 효과를 동적으로 동작시점에 생성 가능하다.

      Spring Container는 객체를 생성하고 객체간의 의존성에 필요한 정보를 제공한다.
      생성된 객체를 Bean이라 부르고, 모든 객체는 Bean단위로 사용된다.

      어플리케이션이 작동하는 시점에서 XML, annoataion설정 정보가 Spring container에 저장되고
      설정 정보를 활용하여 DI를 수행하여 Bean을 생성한다. 소스코드 레벨에서는 클래스가 어떤
      클래스를 참조하는지 알수없고 어플리케이션 동작 시점에 설정파일을 통해 의존성이 결정되므로
      IoC라고 부른다.

      Spring Container의 정보는 ApplicationContext에 의해 관리된다. ApplicationContext는
      bean 생성과 DI, BeanFactory의 생명주기관리, Spring AOP, 메시지 리소스처리, 이벤트 처리등을 제공
      beanfactory의 기능을 모두 포함함으로 다수의 Spring 설정파일을 읽어서 context를 생성하여 활용한다.

      ApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"services.xml","daos.xml"});
      Foo foo = (Foo)context.getBean("foo");

    6.3. DI 활용
      DI를 설정하는 방법 XML/annotaion 2가지 가 있다.
      XML은 설정이 풀편하고 어렵지만 모든 클래스의 의존성 파악 가능
      annotation은 산재되어 파악은 어렵지만 편리하게 설정이 가능
      XML 설정은 Spring 기반으로 구현된 솔루션, 플러그인, 프레임워크등을 활용할때 많이 사용.
      annotaion은 일반 비즈니스 로직 구현으로 활용.

      일반 자바 어플리케이션 DI활용 예제
      가장 먼저 인터페이스를 구현한다 CustomerService 인터페이스는 XML/Annotation 상관없이 활용됨

      * CustormerService interface
      public interface CustomerService {
          String getCustName(String id);
          String getCustGrade(String id);
      }

      6.3.1. XML 설정을 활용한 DI
        XML설정파일은 <beans/>를 root로 가지며, <bean/>을 사용하여 의존성을 설정한다.
        Spring Container에 여러 설정파일을 읽어 활용할 수 있기때문에 내용이 너무 많은 경우
        여러개로 구성하는데 설정내용에 따라 모아서 파일을 구성하는게 일반적이다.
        bean은 id를 가지고 실제 클래스를 맵핑한다. 클래스 정보는 Spring Container에 id와 함께
        저장되어 어플리케이션/다른 bean에서 bean의 id로 해당 클래스를 요청할때 정보를 제공.
        customerXML의 id를 가지는 bean은 실제  lab.CustomerXmlServiceImple 클래스이며,
        property속성(custXMLDAO)이 정의 도어 bean id가  customerXMLDAO이고 클래스는 lab.CustomerXMLDAO로
        Mapping 되어 있다.

        * XML DI설정 context-customer.xml
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns=http://www.springframework.org/schema/beans
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans
               http://www.springframework.org/schema/beans/spring-beans-4.0.xsd">

            <bean id="customerXML" class="lab.CustomerXMLServiceImpl">
                <property name="custXMLDAO" ref="customerXMLDAO" />
            </bean>

            <bean id="customerXMLDAO" class="lab.CustomerXMLDAO"/>
        </beans>

        interface를 반드시 구현해야함(interface안 메소드 전부 포함해서)
        인스턴스는 선언만 하고 new 생성은 하지 않는다.(DI로 new를 생성한것과 같은 역할을 해줌)
        setCustXMLDAO에서 cxmlDAO의 변수로 XML의 property로 설정 되어있는 클래스 정보를 읽어와
        맵핑한다.
        * CustomerXMLServiceImpl 서비스 클래스 작성
        public class CustomerXMLServiceImpl implements CustomerService {
            private CustomerXMLDAO xmlDAO;

            public void setCustXMLDAO(CustomerXMLDAO cxmlDAO) {
                this.xmlDAO = cxmlDAO;
            }

            public String getCustName(String id){
                return xmlDAO.getCustName(id);
            }

            public String getCustGrade(String id) {
                return xmlDAO.getCustGrade(id);
            }
        }
        * CustomerXMLDAO 클래스 작성
        DAO는 서비스에서 받은 값에 문자열을 붙여서 리턴한다.
        XML설정에선 id가 suctomerXMLDAO이고 실제는 CustomerXMLDAO가 property속성으로 레퍼런스 되어있다.
        public class CustomerXMLDAO {
            public String getCustName(String id) {
                return id + " eGovFrame XML";
            }
            public String getCustGrade(String id) {
                return id + " S XML";
            }
        }

      6.3.2. Annotation 설정을 활용한 DI
        annotation은 소스코드에 직접 코딩하는것이 아니라 @의 형태로 메타데이터를 삽입하는것을 의미
        비지니스 로직에 영향을 주지 않고 설정을 추가해준다.
        Spring에서 annotaion을 사용하려면 component-scan을 설정해 주어야한다.
        Spring Container가 실행될때 base package 하위 소스코드의 annotation정보가 Spring container에
        저장된다.

        * context-common.xml 예제
        * base-package에서 lab이라는 스캔할 상위 패키지를 지정하고 있다.
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:context="http://www.springframework.org/schema/context"
               xsi:schemaLocation="http://www.springframework.org/schema/beans
               http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
               http://www.springframework.org/schema/context
               http://www.springframework.org/schema/context/spring-context-4.0.xsd">
            <context:component-scan base-package="lab" />
        </beans>

        Bean 설정을 위해 클래스위에 역할별 annotation을 작성한다.
        비지니스 로직을 구현하는 class는 @Service
        DAO는 @Repository
        MVC에서 사용하는 Controller에는 @Controller로 정의해 준다.
        Bean의 이름은 @Service("customer")형식으로 정의되며 이름을 지정하지 않으면
        class이름의 첫글자를 소준자로 바꾸어 자동으로 지정한다.

        설정된 Bean 정보를 활용하여 DI를 설정할때는 @Resource 또는 @Autowired를 사용한다.
        @Resource의 경우에는 bean의 이름을 지정하여 DI가 가능하고
        @Annotation의 경우에는 같은 타입(interface)을 활용하는 class를 자동으로 매핑하여 DI를 수행한다.
        같은 타입이 다수 존재하는 경우는 에러가 발생하므로 유의해야 한다.
        XML과 Annotation을 이용한 DI는 서로 교차도 가능한데 annotation으로 설정된 bean을 XML로 또는
        XML로 설정된 bean을 annotation으로 DI 설정이 가능하다.
        @Service/Repository등으로 클래스를 annotaion 설정을 해두면 해당하는 이름으로
        다른 class에서 @Resource annotaion으로 잡을수 있다.
        @Service 어노테이션을 가진 class test가 있다면 class call에서 @Resource("test")로 호출하여
        type과 이름만 선언하고 사용 가능

        * 예시
        @Service("customer") [선언된 이름으로 호출이 가능하다]
        public class CustomerAnnotationServiceImpl implements CustomerService {
            @Resource(name="customerdao")[customerdao 클래스에서 선언된 이름이며]
                private CustomerAnnotationDAO customerdao;[생성자 없이 타입과 명만 선언]
                public String getCustName(String id) {
                return customerdao.getCustName(id);
            }
            public String getCustGrade(String id) {
                return customerdao.getCustGrade(id);
            }
        }

      6.3.3. Client 어플리케이션 실행
        서비스임플이 동작하는지 확인하기위해 간단한 클라이언트 어플리케이션을 만들어 확인하는데
        XML이나 Annotation을 통한 DI를 하지는 않고 Spring container의 bean을 검색하는 형태로 작성하고
        테스트를 진행한다.
        * 예제 코드로 샘플을 작성했지만 오류가 수정이 안되서 중단...

      6.3.4. Test 코드(JUnit) 실행
        단위테스트는 소스코드의 중요 로직의 메소드를 실행시켜 결과를 확인할수 있도록한다.
        메소드의 실행결과값을 예상하여 예상과 다르면 에러메시지가 출력된다.
        표준프레임워크에서 제공하는 테스트 케이스 작성 도구는 JUnit이다.
        pom.xml의 dependency중 junit이 등록 되어 있는지 확인한다.

        maven 기반 디렉토리 구조에서 src/test/java와resource가 정의 되어 있다.
        java는 테스트할 소스코드가 위치하고 resource는 테스트에 필요한 설정파일이 들어가야 한다.
        Spring 프레임워크에서 JUnit을 지원하기 위해 Spring Container를 실행할 annotation을 지원한다.
        @RunWith Runner를 지정하는 어노테이션
        @ContextConfiguration은 경로에 해당되는 설정파일을 읽어서 Spring Container를 생성하는 역할
        @Test 테스트케이스들을 의미하는 어노테이션

        * JUnit에서 사용되는 어노테이션 정리
        =============================================================================
        |구분           |Annotation           |설명                                 |
        =============================================================================
        |테스트 환경설정|@RunWith             |Spring 활용 Runner 지정 (SpringJUnit)|
        |               |@ContextConfiguration|Spring Container 생성                |
        |테스트 케이스  |@Before              |테스트케이스 실행 전에 매번 실행 됨  |
        |실행 전 수행   |@BeforeClass         |테스트케이스 실행전에 한 번만 실행 됨|
        |테스트케이스   |@After               |테스트케이스 실행 후에 매번 실행 됨  |
        |실행 후 수행   |@AfterClass          |테스트케이스 실행후에 한 번만 실행 됨|
        |테스트케이스   |@Test                |테스트케이스 실행                    |
        =============================================================================

        앞에서 어플리케이션으로 실행되었던 Customer서비스 실행을 JUnit으로 실행하면
        @ContextConfiguration에서는 test 환경에서 활용될 설정 파일 위치를 지정하고
        src/test/resources 밑의 설정 정보를 읽어오게 된다.
        JUnit이 실행되게 되면 @Test로 설정되어 있는 테스트케이스가 실행되어
        assertEquals가 실행되어 예상 값과 결과 값을 비교하여 결과를 출력하게 된다.

        * JUnit활용 테스트코드 CustomerServiceTest 클래스
        @RunWith(SpringJUnit4ClassRunner.class)
        @ContextConfiguration(locations = {classpath*:META-INF/spring/context-*.xml"})
        public class CustomerServicetest {
            @Resource(name="customerxml")
            CustomerXMLServiceImpl xmlcustomer;
            @Resource(name="customer")
            CustomerAnnotationServiceImpl customer;
            @Test
            public void testMain() {
                assertEquals(customer.getCustName("1"),"1 eGovFrame Annotation");
                assertEquals(customer.getCustGrade("1"),"1 S Annotation");
                assertEquals(xmlcustomer.getCustName("1"),"1 eGovFrame XML");
                assertEquals(xmlcustomer.getCustGrade("1"),"1 S XML"); }
        }

        작성된 테스트코드는 해당 파일을 우클릭해서 Run As > JUnit Test를 선택하면 실행된다.
        성공하면 녹색 막대가 실패하면 에러 메시지와 빨간 막대가 나온다.

  7. Logging
    표준프레임워크의 Logging은 log4j 기반으로 제공된다.
    log4j를 설정하여 원하는 정보와 원하는 로그레벨을 설정할수있다.
    개발시엔 DEBUG로 상세 로그를 운영시에는 INFO, ERROR로 불필요한 정보를 감출수있다.

    7.1. Logging 개요
      Logging 이란 시스템 개발 / 운영시 발생하는 어플리케시연 내부 정보를 시스템외부 저장소에 기록 또는
      화면등에 출력하여 디버그 혹은 상황파악을 지원하는 서비스이다.
      System.out.println()등을 사용하기도 하지만 전체적인 시스템 성능 저하 밑 후에 처리하기가 어려워지는
      단점이 개발과 운영의 효율을 떨어뜨린다.
      log4j는
      패키지별로 상세한 Log 정책 부여
      날짜형식, 시간형식 등 다양한 형식의 메시지 형태 지정가능
      다양한 매체(File, DB, Mail 등)에 대한 Log 관리 가능
      레벨(debug, info 등) 별로 로그를 기록

      * Log4j 중요 컴포넌트
      ========================================================================================
      |컴포넌트| 설 명                                                                       |
      |Logger  | Log파일을 작성하는 클래스로 Log를 기록할 대상을 패키지 또는 클래스          |
      |        | 이름으로 지정하고 이에 대한 로그레벨과 Appender를 지정                      |
      |Appender| Log를 출력하는 위치로 화면, 파일, DB등 지정. 화면출력의 경우 console 지정   |
      |Layout  | Appender의 출력 포맷으로 날짜, 시간, 클래스명 등의 정보를 Log 내용으로 지정 |
      ========================================================================================

      Logger의 중요도에 따라 레벨이 달라지는데 지정된 레벨보다 높은 로그가 같이 출력되므로
      개발시에는 DEBUG로 오류를 파악하고 운영시에는 INFO로 두어 중요한 정보만 확인할수있다.

      * Log레벨
      ====================================================================================
      |Log레벨|설 명                                                                     |
      |Error  |처리 중 문제가 발생한 상태                                                |
      |Warn   |처리 가능한 문제이지만, 향후 시스템 에러의 원인이 될 수 있는 경고성 메시지|
      |Info   |로그인, 상태 변경 등 정보성 메시지                                        |
      |Debug  |개발시 디버그 용도로 사용할 메시지                                        |
      ====================================================================================
    7.2. Log4j 활용
      Log4j를 사용하려면 egovframe.rte.fdl.logging을 참조 가능하도록 설정해야 한다.
      하지만 pom.xml에 직접 설정하지 않아도 egovframe.rte.psl.dataaccess/egovframe.rte.ptl.mvc에
      의해서 자동으로 설정이 된다.
      그리고 설정파일도 필요한데 파일명은 log4j2.xml이고 위치는 src/main/resource에 있다.

      * 설정파일 예제
      <?xml version="1.0" encoding="UTF-8"?>
      <Configuration>
        <Appenders>
          <Console name="console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d %5p [%c] %m%n" />
          </Console>
        </Appenders>
        <Loggers>
          <Logger name="java.sql" level="DEBUG" additivity="false">
            <AppenderRef ref="console" />
          </Logger>
          <Logger name="lab" level="INFO" additivity="false">
            <AppenderRef ref="console" />
          </Logger>
          <Logger name="jdbc.sqltiming" level="INFO" additivity="false">
            <AppenderRef ref="console" />
          </Logger>
          <Logger name="org.springframework" level="INFO" additivity="false">
            <AppenderRef ref="console" />
          </Logger>
          <Root level=“ERROR">
            <AppenderRef ref="console" />
          </Root>
        </Loggers>
      </Configuration>

      LogManager의 getLogger() 메소드를 사용해 logger를 생성해야 한다.
      getLogger()는 static 메소드라서 인스턴스 없이 사용 가능하고 String값을 입력하면 해당 값으로
      class.getName()을 입력하면 로거 이름을 입력한 것과 같게된다.

      * logger 활용 예제
      package lab.ex;

      import org.apache.log4j.Level;
      import org.apache.logging.log4j.Logger;

      import org.apache.logging.log4j.LogManager;

      public class HelloWorldServiceImpl implements HelloWorldService{
        * 클래스 이름으로 지정한 로거 = log4j2.xml의 설정과 같음
        Logger logger = LogManager.getLogger(HelloWorldServiceImpl.class.getName());

        private String name;

        public void setName(String name) {
        this.name = name;
        }

        public String sayHello() {
          * 로그를 2가지 레벨로 출력
          logger.debug("[debug] sayHello executed");
          logger.info("[info] sayHello executed");
          return "Hello " + name + "!!!" ;
        }
      }
  8. AOP(Aspect Oriented Programming)
    반복적으로 처리되고 특정 라이브러리에 의존성이 발생하는 문제를 해결하기위해 처리가 필요한 영역을
    공통모듈로 분리하고 대상과 발생시점을 정의하여 자동적으로 실행될 수 있도록 한 해결 방식

    8.1. AOP 개요
      AOP는 객체지향 프로그래밍을 보완하는 개념 모듈화하여 작성하더라도 발생하는 다수의 객체들에 있는
      중복된 모듈이 존재하게 된다.
      이러한 형상을 AOP에서는 횡단관심(cross concern)이라고 부른다.
      업무처리를 하는 모듈(primary concern)에서 로깅, 보안, 트랜젝션, 예외처리 등의 기술적인 처리를 위한
      소스코드가 포함되어 있다면 업무로직에만 직중하기 어려움이 생긴다.
      또한 기술적인처리를 위한 모듈들과 업무처리 모듈간의 의존성이 생겨 변경에 유연성이 떨어지게 된다.
      AOP는 기술적 처리를 위한 모듈을 advice로 분리하여 별도로 관리하고 advice가 필요한 시점에 작동하도록
      point cut 작동할 대상, joint point 작동할 시점을 규칙으로 정의한다.

      * AOP의 주요 개념
      ==============================================================================
      |개념       |설명                                                            |
      ==============================================================================
      |Joint point|횡단 관심 모듈이 삽입되어 동작할 수 있는 실행 가능한 시점을 결정|
      |           |특정 메소드 실행 전, 후, 결과 값 리턴 등                        |
      ==============================================================================
      |           |Advice         |설명                                            |
      |           |Before         |메소드 호출 전에 수행                           |
      |           |After returning|메소드가 실행되어 결과값이 리턴 된 후 수행      |
      |           |After throwing |예외가 발생되었을 때 수행                       |
      |           |After advice   |메소드가 실행된 후에 수행 (정상,예외에 상관없음)|
      |           |Around         |메소드 실행 전,후에 수행                        |
      ==============================================================================
      |Point cut  |어느 모듈 및 메소드를 대상으로 실행이 되는지를 결정             |
      |           |예를 들어 특정 클래스에 있는 모든 메소드가 호출 될 때           |
      ==============================================================================
      |Advice     |공통활용을 위해 분리된 횡단 관심 모듈 (cross concern)           |
      ==============================================================================
      |Aspect     |Advice와 Point cut의 조합                                       |
      ==============================================================================
      |Weaving    |Joint point와 point cut에 의해 결정된 대상 및 시점에 advice를   |
      |           |실행하는 과정                                                   |
      ==============================================================================

      AOP를 사용하여 얻을수 있는 이점은 아래와 같다.
      여러 모듈에서 반복적으로 기술되는 코드를 제거 할수있다.
      비지니스 로직만 작성할수 있다.(가독성 향상)
      가독성 향상으로 생산성이 증가한다.
      공통코드 사용으로 재사용성이 증가한다.
      공통코드를 사용하므로 소스코드 변경이 용이하다.

    8.2. XML을 활용한 AOP 설정
      AOP 활용을 위해 advice, point cut, joint point를 설정이 필요하다.
      파일명은 임의로 작성 가능하지만 일반적으로 context-advice.xml로 작성한다.

      pint cut 설정은 id와 대상을 expression을 활용하여 지정한다.
      *lab..*Impl.*(..)의 표현은 lab 패키지 밑에 Impl로 되어 있는 모든 클래스의 모든 메소드에
      대해서 AOP를 적용
      Joint point의 설정은 before, after-returning, after-throwing, after, around에 대해서
      각각의 point cut id를 지정하고 실행할 advice의 메소드를 지정
      Before joint point의 경우 point cut은 “targetMethod”이고
      메소드가 실행되기 전에 “beforeTargetMethod”가 실행되게 된다.
      After-returning의 경우 “afterReturningTargetMethod”가 실행되며
      결과값을 “retVal” 변수로 받아오게 된다.
      로그등을 출력하는 등 결과 값을 활용할 경우 사용된다.

      * context-advice.xml 예제파일
      <bean id="adviceUsingXML" class="lab.ex.AdviceUsingXML" />[advice bean 설정]
      <aop:config>
        <aop:pointcut id="targetMethod" expression="execution(* lab..*Impl.*(..))" />[AOP대상 클래스 및 메소드 설정]

        <aop:aspect ref="adviceUsingXML">[Advice bean 설정]
          [Joint point 설정]
          <aop:before pointcut-ref="targetMethod" method="beforeTargetMethod" />
          <aop:after-returning pointcut-ref="targetMethod"
            method="afterReturningTargetMethod" returning="retVal" />
          <aop:after-throwing pointcut-ref="targetMethod"
            method="afterThrowingTargetMethod" throwing="exception" />
          <aop:after pointcut-ref="targetMethod" method="afterTargetMethod" />
          <aop:around pointcut-ref="targetMethod" method="aroundTargetMethod" />
        </aop:aspect>
      </aop:config>

      * point cut 지정자 예제
      ============================================================================
      |지정자     |설명                                                          |
      ============================================================================
      |execution  |메소드에 대해 joint point 정의                                |
      |within     |특정 타입 속하는 joint point 정의                             |
      |this       |빈 참조가 주어진 타입의 인스턴스를 갖는 joint point 정의      |
      |target     |대상 객체가 주어진 타입을 갖는 joint point 정의               |
      |args       |인자가 주어진 타입의 인스턴스인 joint point 정의              |
      |@target    |수행중인 객체의 클래스가 주어진 타입의 annotation을 갖는 joint|
      |           |point 정의                                                    |
      |@args      |전달된 인자의 런타임 타입이 주어진 타입의 annotation을 갖는   |
      |           |joint point 정의                                              |
      |@within    |주어진 annotation을 갖는 타입 내 joint point 정의             |
      |@annotation|대상 객체가 주어진 annotation을 갖는 joint point 정의         |
      ============================================================================
      아래의 정의예제에서 execution은 메소드를 within은 타입을 기준으로 설정하는데
      execution은 메소드별로 AOP를 설정하고 within은 인터페이스별로 설정한다.
      execution에서 모든 메소드를 선택하게 되면 within과 같은 형태로 동작한다.

      =================================================================================================================
      |Point cut                             |Joint points 설정                                                       |
      =================================================================================================================
      |execution(public * *(..))             |public 메소드 실행                                                      |
      |execution(* set*(..))                 |이름이 set으로 시작하는 모든 메소드명 실행                              |
      |execution(* xyz.service.*.*(..))      |service 패키지의 모든 메소드 실행                                       |
      |execution(* xyz.service..*.*(..))     |service 패키지와 하위 패키지의 모든 메소드 실행                         |
      |execution(* xyz.service..*Impl.*(..)) |service 패키지와 하위 패키지의 Impl로끝나는 모든 클래스 모든 메소드 실행|
      |within(com.xyz.service.*) service     |패키지 내의 모든 결합점                                                 |
      |within(com.xyz.service..*) service    |패키지 및 하위 패키지의 모든 결합점                                     |
      |within(com.xyz.service.AccountService)|AccountService 인터페이스의 모든 메소드 실행                            |
      |this(com.xyz.service.AccountService)  |AccountService 인터페이스를 구현하는 프록시 개체의 모든 결합점          |
      |target(com.xyz.service.AccountService)|AccountService 인터페이스를 구현하는 대상객체의 모든 결합점             |
      |args(java.io.Serializable)            |하나의 파라미터를 갖고 전달된 인자가 Serializable인 모든 결합점         |
      =================================================================================================================
      |@target(org.springframework           |대상 객체가 @Transactional 어노테이션을                                 |
      |.transaction.annotation.Transactional)|갖는 모든 결합점                                                        |
      =================================================================================================================
      |@within(org.springframework           |대상 객체의 선언 타입이 @Transactional 어                               |
      |.transaction.annotation.Transactional)|노테이션을 갖는 모든 결합점                                             |
      =================================================================================================================
      |@annotation(org.springframework       |실행 메소드가 @Transactional 어노테이션을                               |
      |.transaction.annotation.Transactional)|갖는 모든 결합점                                                        |
      =================================================================================================================
      |@args(com.xyz.security.Classified)    |단일 파라미터를 받고, 전달된 인자 타입이                                |
      |                                      |@Classified 어노테이션을 갖는 모든 결합점                               |
      =================================================================================================================
      |bean(accountRepository)               |“accountRepository” 빈                                                  |
      |!bean(accountRepository)              |“accountRepository” 빈을 제외한 모든 빈                                 |
      |bean(*)                               |모든 빈                                                                 |
      |bean(account*)                        |이름이 'account'로 시작되는 모든 빈                                     |
      |bean(*Repository)                     |이름이 “Repository”로 끝나는 모든 빈                                    |
      |bean(accounting/*)                    |이름이 “accounting/“로 시작하는 모든 빈                                 |
      |bean(*dataSource) || bean(*DataSource)|이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈                 |
      =================================================================================================================

    8.3. Advice 설정
      AdviceUsingXML 파일의 advice설정 예제
      before, after등의 joint point에서 실행될 메소드를 정의한다.

      public class AdviceUsingXML {

        private static final Logger LOGGER = LogManager.getLogger(AdviceUsingXML.class);

        public void beforeTargetMethod(JoinPoint thisJoinPoint) { [before advice 정의]
          [Joint Point에서 클래스명, 메소드명 정보 가져옴]
          String className = thisJoinPoint.getTarget().getClass().getSimpleName();
          String methodName = thisJoinPoint.getSignature().getName();

          StringBuffer buf = new StringBuffer();
          buf.append("AdviceUsingXML.beforeTargetMethod : [" + className + "." + methodName + "()]");

          Object[] arguments = thisJoinPoint.getArgs();[Joint Point에서 인수정보 가져옴]

          int argCount = 0;

          [인수 값을 문자열로 변환]
          for (Object obj : arguments) {
          buf.append("\n - arg ");
          buf.append(argCount++);
          buf.append(" : ");
          buf.append(ToStringBuilder.reflectionToString(obj));
        }
        LOGGER.debug(buf.toString());
      }

      advice가 실행된후에 작동하는 after메소드이고 이 메소드는
      try문의 finally처럼 오류 정상작동 상관없이 무조건 수행되는 메소드 이다.

      public void afterReturningTargetMethod(JoinPoint thisJoinPoint, Object retVal) {[retVal로 결과값을 전달받음]
        String className = thisJoinPoint.getTarget().getClass().getSimpleName();
        String methodName = thisJoinPoint.getSignature().getName();

        StringBuffer buf = new StringBuffer();
        buf.append("AdviceUsingXML.afterReturningTargetMethod : [" + className + "." + methodName + "()]");
        buf.append("\n");

        if (retVal instanceof List) {
          List<?> resultList = (List<?>) retVal;
          buf.append("resultList size : " + resultList.size() + "\n");

          for (Object oneRow : resultList) {
            buf.append(ToStringBuilder.reflectionToString(oneRow));[결과 값이 다수일때]
            buf.append("\n");
          }
        } else {
          buf.append(ToStringBuilder.reflectionToString(retVal));[결과 값이 단건일때]
        }
        LOGGER.debug(buf.toString());
      }
      
      * Advice의 실행 순서
      =====================================================================
      |   정상실행                    |   예외발생                        |
      =====================================================================                 
      |1. before                      |1. before                          |
      |2. around (대상 메소드 실행 전)|2. around (대상 메소드 실행 전)    |  
      |3. 대상 메소드                 |3. 대상 메소드 (Exception 예외발생)|
      |4. around (대상 메소드 실행 후)|4. after(finally)                  |        
      |5. after(finally)              |5. after throwing                  |
      |6. after-returning             |                                   |
      =====================================================================
      
    8.4. AOP 활용 및 실행결과
      *실행결과 확인용 예제 파일      
      public class HelloWorldServiceImpl implements HelloWorldService{              
        Logger logger1 = LogManager.getLogger(HelloWorldServiceImpl.class.getName());
        private String name;                                                          
        public void setName(String name) {                                            
          this.name = name;                                                             
        }                                                                             
        public String sayHello(String message) {                                      
          logger1.debug("sayHello executed");[정상 작동 부분]
          return "Hello " + name + " "+message ;                                        
        }                                                                             
        public void sayError() {                                                      
          double i = 100/0;[고의로 에러 발생]
        }                                                                             
      }                                                                                                                                                   
      실행 결과는 정상작동후 예외발생방식으로 작동한다.
      
    8.5. 표준프레임워크에서 Exception 처리 AOP 활용
      BizException, Runtime Exception, 실행환경 Exception등을 분기로 AOP로 point cut 설정후에
      해당하는 부분에서 처리하는 공통모듈을 만들수 있다.
  
  9. Data Access(MyBatis)
    Java SQL은 불편하고 반복적인 코드 작성이 필요하면서 SQL이 소스코드상에 존재하여 수정과 관리가 어렵다.
    Mybatis는 XML파일에 SQL을 위치하여 사용성을 높여준다.
      9.1. MySQL DB 활용
        로그인 : mysql -u 아이디 -p 비밀번호;
      9.2. 자바 SQL 프로그래밍
        JDBC 프로그래밍 단계 | 사용 클래스
        JDBC 드라이버 로드 : system.setproperty(), class.forname()
        데이터베이스 연결 : java.sql.connection
        statement 생성 : java.sql.Statement, java.sql.preparedStatement
        sql 문 전송 : java.sql.statement / executequery() 또는 executeupdate()
        결과 받기 : java.sql.resultset
        연결 해제 : java.sql.connection / close()
        
        DB연결을 위한 JDBC 자바 드라이버 규격을 설정해야한다.
        Project build path 설정을 선택하고 Add JARs를 선택하고 mysql-connector-java-5.1.42.jar를 선택한다.
        Maven 프로젝트에서는 pom.xml에 dependency를 추가하면 된다.
        
        Class.for.Name 에 드라이버를 지정한다.
        MySQL 드라이버는 com.mysql.jdbc.Driver이다.
        getConnection으로 DB에 접속되며,
        접속 정보는 JDBC:mysql://[서버 도메인 또는 IP]:포트:DB명의 형태로 구성된다.
        MySQL의 기본 포트는 3306이며 설정을 통해 포트를 변경할 수 있다.
        연결이 된 다음에는 Statement또는 PreparedStatement를 통해 실행 시킬 SQL문을 준비하게 된다.
        Statement를 활용하는 경우에는 Statement 객체 생성 후에 SQL 문장을 변수 처리부와 함께 문자열로 구현한다.
        
        INSERT나 UPDATE에서 반복적으로 SQL을 실행는 경우에는 PreparedStatement를 쓰는 것이 성능이 우수하다.
        Statement를 활용하게 되면 DB에서 매번 새롭게 Parsing 처리를 하기 때문에 성능이 저하된다.
        PreparedStatement를 활용하는 경우에는 SQL문에는 “?”로 변수 처리를 하고 setString을 활용하여 값을 대입한다.
        
        83쪽